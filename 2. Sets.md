# Sets

### Introduction

A **Set** is a data structure that takes a piece of data and adds it to a container which you can only pull out the last item that was put into it. Effectively creating a last in first out or *LIFO*. This is used for various effects and a wide range of problems. It is implemented within python using a list/array.

Consider the way that you eat icecream for example. The first bites of icecream that you eat when you pull out those first scoops were the last drops of icecream placed within that container during production. **The carton is filled from bottom to top.** Code inside of a **stack** is much the same. You store the first *bits* of code at the bottom of the **stack** and pile other pieces on top of it.

### Purpose and Characteristics

Perhaps the most important of the different uses of the **stack** is that of function calls, especially when these are "nested" and you begin going multiple layers deep calling one function after another. The structure that keeps track of these layers and then is able to go back up the line and return to your original function call with all the relevant data retrieved is the Stack.

One other major purpose of the **stack** is an allowance for a user to reverse the order of data that has been put onto the stack. This functionality is used throughout every day life in the form of the back button on your phone or computer, the undo text operation or even putting your undone actions onto another stack so that you can redo items that you have undone. This is especially true with my coding experience. It feels like every line I type contains at least one instance of me *undoing* what I just typed instead of pressing the backspace. Alongside this every few minutes I find that I've accidentally deleted something and have to *redo* what was previously typed.



### Performance

Performance of a **Set** with common operations

Operation | Usage | Python Usage | Performance 
----------|-------|--------------|------------
Push       | my_stack.append(item) | Put data onto the top of the stack | 0(1)
Pop    | my_stack.pop() | Take the last item off the top of the stack | 0(1)
Length    | len(my_stack) | Find the number of items on the stack | 0(1)
Empty     | if len(my_stack) == 0: | Check to see if the stack is empty | 0(1)

### Example
```python
"""
The following is a basic implementation of a SET

Problem: Check to see how many unique individuals
bought tickets
"""
ticket_buyers = ["George", "Jen", "Frankie", "Pikachu", "This-Guy", "George", "Ben", "Ben"]
# As you can see both George and Ben in this list have bought more than 1 ticket. In a list
# this size it is easy for us to check it ourselves. But imagine for a giant concert where
# They may sell 20,000+ tickets and want to know the number of unique fans who bought tickets

# This can be solved by taking the array and changing it into a set and then comparing the
# Difference in length.
duplicate_buyers = len(ticket_buyers) - len(set(ticket_buyers))

unique_buyers = len(ticket_buyers) - duplicate_buyers
print(duplicate_buyers) # Prints 2
print(unique_buyers) # Prints 6
```

### Problem to Solve
```python
"""
We are trying to figure out if we are accidentally paying one
of our employees more than once. Given a list of employee ID's
determine if we have included more than one of their ID's
"""
employees1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 123, 5125, 6436, 43, 3, 435, 1]
employees2 = []
employees3 = [1, 2, 3]
employees4 = [1, 4, 61]

def main(array):
    pass
        
# Expect True
main(employees1)

# Expect False
main(employees2)

# Expect False
main(employees3)

# Expect False
main(employees4)
```

[ProblemSolution](2.2%20Sets_problem_solution.py)
